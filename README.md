# pandas
let us learn pandas easily and happily~

# 6.缺失数据
## 一、缺失观测及其类型
### 1.了解缺失信息 
isna和notna方法

但对于DataFrame我们更关心到底每列有多少缺失值,df.isna().sum()

此外，可以通过第1章中介绍的info函数查看缺失信息,df.info()

#### 查看缺失值的所在行
df[df['Physics'].isna()]
#### 挑选出所有非缺失值列
df[df.notna().all(1)]

### 2. 三种缺失符号
#### np.nan
它在numpy中的类型为浮点，由此导致数据集读入时，即使原来是整数的列，只要有缺失值就会变为浮点型

对于布尔类型的列表，如果是np.nan填充，那么它的值会自动变为True而不是False

但当修改一个布尔列表时，会改变列表类型（变为float64），而不是赋值为True
#### None
它的布尔值为False 

修改布尔列表不会改变数据类型
#### NaT
NaT是针对时间序列的缺失值，是Pandas的内置类型，可以完全看做时序版本的np.nan，与自己不等，且使用equals是也会被跳过

修改布尔列表会改变数据类型

在传入数值类型后，会自动变为np.nan

只有当传入object类型是保持不动，几乎可以认为，除非人工命名None，它基本不会自动出现在Pandas中
### 3. Nullable类型与NA符号
#### Nullable整型 float：NaN int：<NA>
它与原来标记int上的符号区别在于首字母大写：'Int’

它的好处就在于，其中前面提到的三种缺失值都会被替换为统一的NA符号，且不改变数据类型

#### Nullable布尔
对于该种类型而言，作用与上面的类似，记号为boolean

#### string类型
该类型是1.0的一大创新，目的之一就是为了区分开原本含糊不清的object类型，这里将简要地提及string，因为它是第7章的主题内容

它本质上也属于Nullable类型，因为并不会因为含有缺失而改变类型

此外，和object类型的一点重要区别就在于，在调用字符方法后，string类型返回的是Nullable类型，object则会根据缺失类型和数据类型而改变

### 4. NA的特性
#### 逻辑运算
只需看该逻辑运算的结果是否依赖pd.NA的取值，如果依赖，则结果还是NA，如果不依赖，则直接计算结果
#### 算术运算和比较运算
这里只需记住除了下面两类情况，其他结果都是NA即可
### 5.convert_dtypes方法
这个函数的功能往往就是在读取数据时，就把数据列转为Nullable类型，是1.0的新函数

## 二、缺失数据的运算与分组
### 1. 加号与乘号规则
使用加法时，缺失值为0

使用乘法时，缺失值为1

使用累计函数时，缺失值自动略过

### 2. groupby方法中的缺失值
自动忽略为缺失值的组 

## 三、填充与剔除
### 1. fillna方法
#### （a）值填充与前后向填充（分别与ffill方法和backfill方法等价）

#### （b）填充中的对齐特性

### 2. dropna方法
#### （a）axis参数 0为行，1为列
#### （b）how参数（可以选all或者any，表示全为缺失去除和存在缺失去除）
#### （c）subset参数（即在某一组列范围中搜索缺失值）
df_d.dropna(axis=0,subset=['B','C'])：axis=0是行，再利用subset来选定列

##  四、插值（interpolation）
### 1. 线性插值
#### （a）索引无关的线性插值
默认状态下，interpolate会对缺失的值进行线性插值
#### （b）与索引有关的插值
method中的index和time选项可以使插值线性地依赖索引，即插值为索引的线性函数
如果索引是时间，那么可以按照时间长短插值，对于时间序列将在第9章详细介绍

### 2. 高级插值方法
此处的高级指的是与线性插值相比较，例如样条插值、多项式插值、阿基玛插值等（需要安装Scipy）
关于这部分仅给出一个官方的例子，因为插值方法是数值分析的内容，而不是Pandas中的基本知识：

### 3. interpolate中的限制参数
#### （a）limit表示最多插入多少个
#### （b）limit_direction表示插值方向，可选forward,backward,both，默认前向
也就是根据前面还是后面的值来进行插值填充
#### （c）limit_area表示插值区域，可选inside,outside，默认None
